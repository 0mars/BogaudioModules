
#include "FMOp.hpp"
#include "dsp/pitch.hpp"

void FMOp::onReset() {
	_steps = modulationSteps;
	_envelope.reset();
	_gateTrigger.reset();
}

void FMOp::onSampleRateChange() {
	_steps = modulationSteps;
	_envelope.setSampleRate(engineGetSampleRate());
	_phasor.setSampleRate(engineGetSampleRate());
	_sineTable.setSampleRate(engineGetSampleRate());
}

void FMOp::step() {
	lights[BYPASS_LIGHT].value = !_envelopeOn;
	lights[NEGATIVE_LIGHT].value = 0.0f;
	if (!(outputs[PITCH_OUTPUT].active || outputs[GATE_OUTPUT].active || outputs[AUDIO_OUTPUT].active)) {
		return;
	}

	float pitchIn = 0.0f;
	if (inputs[PITCH_INPUT].active) {
		pitchIn = inputs[PITCH_INPUT].value;
	}
	float gateIn = 0.0f;
	if (inputs[GATE_INPUT].active) {
		gateIn = inputs[GATE_INPUT].value;
	}

	++_steps;
	if (_steps >= modulationSteps) {
		_steps = 0;

		float ratio = params[RATIO_PARAM].value;
		if (ratio < 0.0f) {
			ratio = std::max(1.0f + ratio, 0.01f);
		}
		else {
			ratio *= 9.0f;
			ratio += 1.0f;
		}
		_baseHZ = pitchIn;
		_baseHZ += params[FINE_PARAM].value;
		_baseHZ = cvToFrequency(_baseHZ);
		_baseHZ *= ratio;

		bool envelopeOn = params[BYPASS_PARAM].value < 0.5f;
		if (_envelopeOn != envelopeOn) {
			if (_envelopeOn) {
				_envelope.reset();
			}
			_envelopeOn = envelopeOn;
		}
		if (_envelopeOn) {
			float sustain = params[SUSTAIN_PARAM].value;
			if (inputs[SUSTAIN_INPUT].active) {
				sustain *= clamp(inputs[SUSTAIN_INPUT].value / 10.0f, 0.0f, 1.0f);
			}
			_envelope.setAttack(params[ATTACK_PARAM].value);
			_envelope.setDecay(params[DECAY_PARAM].value);
			_envelope.setSustain(sustain);
			_envelope.setRelease(params[RELEASE_PARAM].value);
		}

		_feedback = params[FEEDBACK_PARAM].value;
		if (inputs[FEEDBACK_INPUT].active) {
			_feedback *= clamp(inputs[FEEDBACK_INPUT].value / 10.0f, 0.0f, 1.0f);
		}

		_depth = params[DEPTH_PARAM].value;
		if (inputs[DEPTH_INPUT].active) {
			_depth *= clamp(inputs[DEPTH_INPUT].value / 10.0f, 0.0f, 1.0f);
		}

		_level = params[LEVEL_PARAM].value;
		if (inputs[LEVEL_INPUT].active) {
			_level *= clamp(inputs[LEVEL_INPUT].value / 10.0f, 0.0f, 1.0f);
		}
	}

	_phasor.setFrequency(_baseHZ);
	float offset = _feedback * _phasor.next();
	if (inputs[FM_INPUT].active) {
		offset += clamp(inputs[FM_INPUT].value / 5.0f, -1.0f, 1.0f) * _depth * 10.0f;
	}
	float out = _sineTable.nextFromPhasor(_phasor, Phasor::radiansToPhase(offset));
	out *= _level;
	if (_envelopeOn) {
		_gateTrigger.process(gateIn);
		_envelope.setGate(_gateTrigger.isHigh());
		out *= _envelope.next();
	}
	lights[NEGATIVE_LIGHT].value = _phasor._delta + offset < 0.0f;

	outputs[PITCH_OUTPUT].value = pitchIn;
	outputs[GATE_OUTPUT].value = gateIn;
	outputs[AUDIO_OUTPUT].value = out * 5.0f;
}

struct FMOpWidget : ModuleWidget {
	FMOpWidget(FMOp* module) : ModuleWidget(module) {
		box.size = Vec(RACK_GRID_WIDTH * 20, RACK_GRID_HEIGHT);

		{
			SVGPanel *panel = new SVGPanel();
			panel->box.size = box.size;
			panel->setBackground(SVG::load(assetPlugin(plugin, "res/FMOp.svg")));
			addChild(panel);
		}

		addChild(Widget::create<ScrewSilver>(Vec(15, 0)));
		addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 30, 0)));
		addChild(Widget::create<ScrewSilver>(Vec(15, 365)));
		addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 30, 365)));

		// generated by svg_widgets.rb
		auto ratioParamPosition = Vec(40.5, 50.5);
		auto fineParamPosition = Vec(120.0, 62.0);
		auto attackParamPosition = Vec(40.5, 130.5);
		auto decayParamPosition = Vec(95.5, 130.5);
		auto sustainParamPosition = Vec(150.5, 130.5);
		auto releaseParamPosition = Vec(205.5, 130.5);
		auto bypassParamPosition = Vec(78.0, 174.5);
		auto depthParamPosition = Vec(40.5, 215.5);
		auto feedbackParamPosition = Vec(95.5, 215.5);
		auto levelParamPosition = Vec(150.5, 215.5);

		auto sustainInputPosition = Vec(13.0, 273.0);
		auto depthInputPosition = Vec(53.0, 273.0);
		auto feedbackInputPosition = Vec(93.0, 273.0);
		auto levelInputPosition = Vec(133.0, 273.0);
		auto pitchInputPosition = Vec(13.0, 323.0);
		auto gateInputPosition = Vec(53.0, 323.0);
		auto fmInputPosition = Vec(93.0, 323.0);

		auto pitchOutputPosition = Vec(183.0, 323.0);
		auto gateOutputPosition = Vec(223.0, 323.0);
		auto audioOutputPosition = Vec(263.0, 323.0);

		auto bypassLightPosition = Vec(20.0, 177.5);
		auto negativeLightPosition = Vec(255.0, 287.5);
		// end generated by svg_widgets.rb

		addParam(ParamWidget::create<Knob38>(ratioParamPosition, module, FMOp::RATIO_PARAM, -1.0, 1.0, 0.0));
		addParam(ParamWidget::create<Knob16>(fineParamPosition, module, FMOp::FINE_PARAM, -1.0, 1.0, 0.0));
		addParam(ParamWidget::create<Knob26>(attackParamPosition, module, FMOp::ATTACK_PARAM, 0.0, 1.0, 0.1));
		addParam(ParamWidget::create<Knob26>(decayParamPosition, module, FMOp::DECAY_PARAM, 0.0, 1.0, 0.1));
		addParam(ParamWidget::create<Knob26>(sustainParamPosition, module, FMOp::SUSTAIN_PARAM, 0.0, 1.0, 1.0));
		addParam(ParamWidget::create<Knob26>(releaseParamPosition, module, FMOp::RELEASE_PARAM, 0.0, 1.0, 0.3));
		addParam(ParamWidget::create<StatefulButton9>(bypassParamPosition, module, FMOp::BYPASS_PARAM, 0.0, 1.0, 1.0));
		addParam(ParamWidget::create<Knob26>(depthParamPosition, module, FMOp::DEPTH_PARAM, 0.0, 1.0, 0.5));
		addParam(ParamWidget::create<Knob26>(feedbackParamPosition, module, FMOp::FEEDBACK_PARAM, 0.0, 1.0, 0.0));
		addParam(ParamWidget::create<Knob26>(levelParamPosition, module, FMOp::LEVEL_PARAM, 0.0, 1.0, 1.0));

		addInput(Port::create<Port24>(sustainInputPosition, Port::INPUT, module, FMOp::SUSTAIN_INPUT));
		addInput(Port::create<Port24>(depthInputPosition, Port::INPUT, module, FMOp::DEPTH_INPUT));
		addInput(Port::create<Port24>(feedbackInputPosition, Port::INPUT, module, FMOp::FEEDBACK_INPUT));
		addInput(Port::create<Port24>(levelInputPosition, Port::INPUT, module, FMOp::LEVEL_INPUT));
		addInput(Port::create<Port24>(pitchInputPosition, Port::INPUT, module, FMOp::PITCH_INPUT));
		addInput(Port::create<Port24>(gateInputPosition, Port::INPUT, module, FMOp::GATE_INPUT));
		addInput(Port::create<Port24>(fmInputPosition, Port::INPUT, module, FMOp::FM_INPUT));

		addOutput(Port::create<Port24>(pitchOutputPosition, Port::OUTPUT, module, FMOp::PITCH_OUTPUT));
		addOutput(Port::create<Port24>(gateOutputPosition, Port::OUTPUT, module, FMOp::GATE_OUTPUT));
		addOutput(Port::create<Port24>(audioOutputPosition, Port::OUTPUT, module, FMOp::AUDIO_OUTPUT));

		addChild(ModuleLightWidget::create<TinyLight<GreenLight>>(bypassLightPosition, module, FMOp::BYPASS_LIGHT));
		addChild(ModuleLightWidget::create<TinyLight<RedLight>>(negativeLightPosition, module, FMOp::NEGATIVE_LIGHT));
	}
};

Model* modelFMOp = Model::create<FMOp, FMOpWidget>("Bogaudio", "Bogaudio-FMOp", "FM-OP");

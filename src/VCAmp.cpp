
#include "VCAmp.hpp"

void VCAmp::step() {
	if (inputs[IN_INPUT].active && outputs[OUT_OUTPUT].active) {
		float level = params[LEVEL_PARAM].value;
		if (inputs[CV_INPUT].active) {
			level *= clamp(inputs[CV_INPUT].value, 0.0f, 10.0f) / 10.0f;
		}
		level *= maxDecibels - minDecibels;
		level += minDecibels;
		_amplifier.setLevel(level);
		outputs[OUT_OUTPUT].value = _amplifier.next(inputs[IN_INPUT].value);
	}
}

struct VUSlider : Knob {
	const float slideHeight = 13.0f;

	VUSlider() {
		box.size = Vec(18.0f, 183.0f);
	}

	virtual void draw(NVGcontext* vg) override {
		nvgSave(vg);
		{
			nvgBeginPath(vg);
			nvgRoundedRect(vg, 6, 3, 6, 177, 2);
			nvgFillColor(vg, nvgRGBA(0x22, 0x22, 0x22, 0xff));
			nvgFill(vg);
			nvgStrokeColor(vg, nvgRGBA(0x88, 0x88, 0x88, 0xff));
			nvgStroke(vg);
		}
		nvgRestore(vg);

		nvgSave(vg);
		{
			nvgTranslate(vg, 0, 170.0f * (1.0f - value));
			nvgBeginPath(vg);
			nvgRoundedRect(vg, 0, 0, 18, 13, 1.5);
			nvgFillColor(vg, nvgRGBA(0x77, 0x77, 0x77, 0xff));
			nvgFill(vg);

			nvgBeginPath(vg);
			nvgRect(vg, 0, 2, 18, 9);
			nvgFillColor(vg, nvgRGBA(0x44, 0x44, 0x44, 0xff));
			nvgFill(vg);

			nvgBeginPath(vg);
			nvgRoundedRect(vg, 2, 4, 14, 5, 1.0);
			nvgFillColor(vg, nvgRGBA(0xaa, 0xaa, 0xaa, 0xff));
			nvgFill(vg);

			float db = -60.0f + value * 72.0f;
			if (db > -60.0f) {
				nvgBeginPath(vg);
				nvgRoundedRect(vg, 2, 4, 14, 5, 1.0);
				if (db < -12.0f) {
					nvgFillColor(vg, nvgRGBA(0x00, 0xff, 0x00, (1.0f - (db + 12.0f) / -48.0f) * (float)0xff));
				}
				else if (db < 0.0f) {
					nvgFillColor(vg, nvgRGBA((1.0f - db / -12.0f) * 0xff, 0xff, 0x00, 0xff));
				}
				else {
					nvgFillColor(vg, nvgRGBA(0xff, (1.0f - db / 12.0f) * 0xff, 0x00, 0xff));
				}
				nvgFill(vg);
			}
		}
		nvgRestore(vg);
	}
};

struct VCAmpWidget : ModuleWidget {
	VCAmpWidget(VCAmp* module) : ModuleWidget(module) {
		box.size = Vec(RACK_GRID_WIDTH * 3, RACK_GRID_HEIGHT);

		{
			SVGPanel *panel = new SVGPanel();
			panel->box.size = box.size;
			panel->setBackground(SVG::load(assetPlugin(plugin, "res/VCAmp.svg")));
			addChild(panel);
		}

		addChild(Widget::create<ScrewSilver>(Vec(0, 0)));
		addChild(Widget::create<ScrewSilver>(Vec(box.size.x - 15, 365)));

		// generated by svg_widgets.rb
		auto levelParamPosition = Vec(13.5, 18.0);

		auto cvInputPosition = Vec(10.5, 213.0);
		auto inInputPosition = Vec(10.5, 248.0);

		auto outOutputPosition = Vec(10.5, 286.0);
		// end generated by svg_widgets.rb

		addParam(ParamWidget::create<VUSlider>(
			levelParamPosition,
			module,
			VCAmp::LEVEL_PARAM,
			0.0,
			1.0,
			abs(module->minDecibels) / (module->maxDecibels - module->minDecibels)
		));

		addInput(Port::create<Port24>(cvInputPosition, Port::INPUT, module, VCAmp::CV_INPUT));
		addInput(Port::create<Port24>(inInputPosition, Port::INPUT, module, VCAmp::IN_INPUT));

		addOutput(Port::create<Port24>(outOutputPosition, Port::OUTPUT, module, VCAmp::OUT_OUTPUT));
	}
};

Model* modelVCAmp = Model::create<VCAmp, VCAmpWidget>("Bogaudio", "Bogaudio-VCAmp", "VCAmp", AMPLIFIER_TAG, ATTENUATOR_TAG, UTILITY_TAG);

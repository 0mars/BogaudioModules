#!/usr/bin/ruby

INKSCAPE = '/Applications/Inkscape.app/Contents/Resources/bin/inkscape'
OUTPUT_DECIMAL_PLACES=2

require 'optparse'

options = {
  output: 'list',
  variable_style: 'positions',
  module: 'MODULE',
  param_class: 'RoundBlackKnob',
  input_class: 'PJ301MPort',
  output_class: 'PJ301MPort',
  light_class: 'TinyLight<GreenLight>',
  comments: false,
  sort: nil
}
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] <svg file>"
  opts.on('--list', 'Output list of widget IDs, positions and dimensions (default)') do
    options[:output] = 'list'
  end
  opts.on('--ids', 'Output list of widget IDs only') do
    options[:output] = 'ids'
  end
  opts.on('--variables=[STYLE]', %w(positions accessors parameters members initializers), 'Output variable declarations for each widget\'s position') do |v|
    options[:output] = 'variables'
    options[:variable_style] = v if v
  end
  opts.on('--creates', 'Output createParam, etc, lines for each widget') do
    options[:output] = 'creates'
  end
  opts.on('--enums', 'Output param/input/output/light ID enums') do
    options[:output] = 'enums'
  end
  opts.on('--module=MODULE', 'Name of the module class: used with --creates (default: MODULE)') do |v|
    options[:module] = v
  end
  opts.on('--param-class=CLASS', 'Widget type for params: used with --creates (default: RoundBlackKnob)') do |v|
    options[:param_class] = v
  end
  opts.on('--input-class=CLASS', 'Widget type for inputs: used with --creates (default: PJ301MPort)') do |v|
    options[:input_class] = v
  end
  opts.on('--output-class=CLASS', 'Widget type for outputs: used with --creates (default: PJ301MPort)') do |v|
    options[:output_class] = v
  end
  opts.on('--light-class=CLASS', 'Widget type for lights: used with --creates (default: "TinyLight<GreenLight>")') do |v|
    options[:light_class] = v
  end
  opts.on('--comments', 'Output "generated by" comments around code') do
    options[:comments] = true
  end
  opts.on('--sort=SORT', %w(ids position), 'Sort widgets for output; "ids" to sort alphabetically, "position" to sort top-down and left-right') do |v|
    options[:sort] = v
  end
  opts.on_tail('-h', '--help', 'Show this message') do
    puts opts
    exit
  end
end
begin
  option_parser.parse!
rescue => e
  STDERR.puts e.to_s
  STDERR.puts "\n"
  STDERR.puts option_parser.help
  exit 1
end

unless ARGV.size >= 1
  STDERR.puts option_parser.help
  exit 1
end
svg_file = ARGV[0]
unless File.exist?(svg_file)
  STDERR.puts "No such file: #{svg_file}"
  exit 1
end
svg_file = File.absolute_path(svg_file)

lines = `#{INKSCAPE} -z -S #{svg_file}`
exit unless lines =~ /_(PARAM|INPUT|OUTPUT|LIGHT)/

Widget = Struct.new(:id, :x, :y, :width, :height) do
  def to_s
    "#{id} x=#{x} y=#{y} width=#{width} x=#{height}"
  end
end
widgets_by_type = {}
widget_re = %r{^(\w+_(PARAM|INPUT|OUTPUT|LIGHT)),(\d+(?:\.\d+)?),(\d+(?:\.\d+)?),(\d+(?:\.\d+)?),(\d+(?:\.\d+)?)}
lines.split.each do |line|
  if m = widget_re.match(line)
    widget = Widget.new(
      m[1],
      m[3].to_f.round(OUTPUT_DECIMAL_PLACES),
      m[4].to_f.round(OUTPUT_DECIMAL_PLACES),
      m[5].to_f.round(OUTPUT_DECIMAL_PLACES),
      m[6].to_f.round(OUTPUT_DECIMAL_PLACES)
    )
    (widgets_by_type["#{m[2].downcase}s"] ||= []) << widget
  end
end

if options[:sort]
  %w(params inputs outputs lights).each do |type|
    next unless widgets_by_type.key?(type)
    widgets_by_type[type].sort! do |a, b|
      case options[:sort]
      when 'position'
        a.y <=> b.y || a.x <=> b.x || a.id <=> b.id
      else
        a.id <=> b.id
      end
    end
  end
end

def titleize(s)
  return s unless s =~ /_/
  ss = s.downcase.split(/_+/)
  "#{ss[0]}#{ss[1..-1].map { |s| "#{s[0].upcase}#{s[1..-1]}" }.join('')}"
end

puts "// generated by #{File.basename($0)}" if options[:comments] && %(variables creates enums).include?(options[:output])
case options[:output]
when 'ids'
  groups = %w(params inputs outputs lights).map do |type|
    (widgets_by_type[type] || []).map(&:id)
  end
  puts groups.reject(&:empty?).map { |g| g.join("\n") }.join("\n\n")
when 'variables'
  groups = [%w(params Param), %w(inputs Input), %w(outputs Output), %w(lights Light)].map do |type|
    (widgets_by_type[type[0]] || []).map do |w|
      case options[:variable_style]
      when 'accessors'
        "#{type[0]}[#{w.id}];"
      when 'parameters'
        "#{type[1]}& #{titleize(w.id)},"
      when 'members'
        "#{type[1]}& _#{titleize(w.id)};"
      when 'initializers'
        s = titleize(w.id)
        ", _#{s}(#{s})"
      else
        "auto #{titleize(w.id)}Position = Vec(#{w.x}, #{w.y});"
      end
    end
  end
  puts groups.reject(&:empty?).map { |g| g.join("\n") }.join("\n\n")
when 'creates'
  groups = []
  groups << (widgets_by_type['params'] || []).map do |w|
    "addParam(createParam<#{options[:param_class]}>(#{titleize(w.id)}Position, module, #{options[:module]}::#{w.id}, 0.0, 1.0, 0.5));"
  end.join("\n")
  groups << (widgets_by_type['inputs'] || []).map do |w|
    "addInput(createInput<#{options[:input_class]}>(#{titleize(w.id)}Position, module, #{options[:module]}::#{w.id}));"
  end.join("\n")
  groups << (widgets_by_type['outputs'] || []).map do |w|
    "addOutput(createOutput<#{options[:output_class]}>(#{titleize(w.id)}Position, module, #{options[:module]}::#{w.id}));"
  end.join("\n")
  groups << (widgets_by_type['lights'] || []).map do |w|
    "addChild(createLight<#{options[:light_class]}>(#{titleize(w.id)}Position, module, #{options[:module]}::#{w.id}));"
  end.join("\n")
  puts groups.reject(&:empty?).join("\n\n")
when 'enums'
  groups = %w(Params Inputs Outputs Lights).map do |type|
    "enum #{type}Ids {\n  #{(widgets_by_type[type.downcase] || []).map(&:id).join(",\n  ")},\n  NUM_#{type.upcase}\n};"
  end
  puts groups.join("\n\n")
else
  puts "Params:"
  puts widgets_by_type['params']
  puts "\nInputs:"
  puts widgets_by_type['inputs']
  puts "\nOutputs:"
  puts widgets_by_type['outputs']
  puts "\nLights:"
  puts widgets_by_type['lights']
end
puts "// end generated by #{File.basename($0)}" if options[:comments] && options[:output] != 'list'
